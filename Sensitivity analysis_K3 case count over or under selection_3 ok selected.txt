
#Package Loading#

library(MASS)
library(mvtnorm)
library(MCMCpack)
library(gtools)
library(cluster)

#######################
#Function Reordering###
#######################
reorder<-function(mu,H,z,d){
K=ncol(mu)
p=nrow(mu)
n=length(H)
stop=FALSE;l=1:K
#id=1:K;
for (i in 1:p){
if (stop) break;
lc=l[order(mu[i,l])]
mutemp=mu;Htemp=H;dtemp=d;ztemp=z;
for (t in 1:length(lc)){
mu[,l[t]]=mutemp[,lc[t]];
z[,l[t]]=ztemp[,lc[t]];
H[Htemp==lc[t]]=l[t];
d[l[t]]=dtemp[lc[t]];
}
l=sort(l[mu[i,l]==0])
if (length(l)<=1) stop=TRUE 
}
list("mu"=as.matrix(mu),"H"=H,"z"=as.matrix(z),"d"=d)
}#reorder

MAE<-rep(0,10)
OVER<-rep(0,10)
UNDER<-rep(0,10)


cutoff=0.5

for (mt in 1:10){

set.seed(sample(1:100000, 1))




###########
#Simulation(n200,p10,10%,K2,low.sig,no,cenlow)
###########
p=20; n=500; K=3; d_t=rep(1/K,K);

X=matrix(0,n,p);
tau2_t=1;
z_t=matrix(0,p,K);
mu_t=matrix(0,p,K);

H_t=sample(1:K,n,replace=TRUE,d_t)

newp=reorder(mu_t,H_t,z_t,d_t);
mu_t=newp$mu;
H_t=newp$H;
z_t=newp$z;
d_t=newp$d;

Y=rep(0,n);

id=1:n


## generate word matrix ##

idk_s=list()
dm=list()

for (k in 1:K){

idk_s[[k]]=id[H_t==k]
p1=5 #number of variables as a dimension per each K
dm[[k]] <- sample(1:p, p1 ,replace = FALSE) #a dimension of the selected variables (cooccurring words)

idkk <- idk_s[[k]]
dmk<-dm[[k]]

idnk<-length(idkk)

X[idkk,dmk]=sample(c(1,0), p1*idnk, replace = TRUE, prob=c(0.9,0.1)) #co-occur
X[idkk,-dmk]=sample(c(0,1), idnk*(p-p1), replace = TRUE, prob=c(0.6,0.3))

} # for k -- Word Matrix

X1<-X
X1[X>0]=1
dist(t(X1[idk_s[[k]],]))

X<-scale(X*sample(1:5,n*p, replace = TRUE, prob=c(0.4,0.3,0.1,0.1,0.1)))

check=rep(0,n)
for (i in 1:n){
check[i]=sum(X[i,])
}

which(check==0) #checking the word matrix

ps<-round(p*0.2,0)

z_t[,1]=rep(0,p); z_t[dm[[1]],1]=1; z_t[1:ps,1]=1
z_t[,2]=rep(0,p); z_t[dm[[2]],2]=1; z_t[(ps+1):(2*ps),2]=1
#z_t[,3]=c(rep(1,3),rep(0,18))

mu_t[,1]=rep(0,p); mu_t[dm[[1]],1]=round(runif(length(dm[[1]]),1,2),1); mu_t[1:ps,1]=1.5
mu_t[,2]=rep(0,p); mu_t[dm[[2]],2]=round(runif(length(dm[[2]]),1,2),1); mu_t[(ps+1):(2*ps),2]=1
mu_t[,3]=rep(0,p);mu_t[dm[[3]],3]=round(runif(length(dm[[3]]),1,2),1); mu_t[(2*ps+1):(3*ps),2]=1.5
#mu_t[,4]=rep(0,p);mu_t[dm[[4]],4]=round(runif(length(dm[[4]]),1,2),1); mu_t[(3*ps+1):(4*ps),2]=2

mu_t[,1]=rnorm(p,mu_t[,1],0.01)
mu_t[,2]=rnorm(p,mu_t[,2],0.01)
mu_t[,3]=rnorm(p,mu_t[,3],0.01)
#mu_t[,4]=rnorm(p,mu_t[,4],0.01)

mu_t1<-mu_t
z_t1<-z_t

#sig2_t=sum(mu_t^2)/K/40;
sig2_t=0.01

for(i in 1:n)
Y[i]=X[i,]%*%mu_t[,H_t[i]]+rnorm(1,0,sqrt(sig2_t))
Y_t=Y


##Pre-specifying############################

K=3

T0=1000 #Burn-in
T=1000 #Sampling



#### sensitivity hyperparameters
sp1=1;sp2=1;r1=1;r2=0.01; 

theta=rep(1,K);
liks=NULL;m=1;marls=NULL

#dimensions
n=length(Y);
p=dim(X)[2];

#instore posterior sampling
#postalp=NULL;
postz=array(0,c(p,K,T))
postmu=array(0,c(p,K,T))
posttau2=matrix(0,T,p);
postw=NULL;
postsig2=NULL;
postd=matrix(0,T,K);
postpx=NULL;
postH=matrix(0,T,n);
postnk=matrix(0,T,K);
postp=matrix(0,m,n);

setidT=array(0,c(p,p,K,T))

#initionation
d=theta/sum(theta);
tau2=rep(rinvgamma(1,sp1,sp2),p);
w=0.5;
sig2=rinvgamma(1,r1,r2);

z=matrix(as.numeric(runif(p*K)>w), p,K);
mu=matrix(rnorm(p*K,0,1),p,K);
H=sample(1:K, n, replace=T, prob=d)

newp=reorder(mu,H,z,d);
mu=newp$mu;
H=newp$H;
z=newp$z;
d=newp$d;

V=matrix(0,p,K); 

X1<-X
X1[X>0]=1

J = 0.01 # tuning parameter: 0, 0.05, as increase J,correlated selection becomes stonger 

################## MCMC ##################
for (iter in 1:(T0+T)){
if (iter/100==round(iter/100,dig=0)) print(iter) # print number of itertations

nk=rep(0,K);id=1:n;
for(i in 1:n) {
nk[H[i]]=nk[H[i]]+1
} # n of k segment

for(k in 1:K){
idk=id[H==k]
for(j in 1:p) 
V[j,k]=sum(X[idk,j]^2)
}

setidS=array(0,c(p,p,K))

########## sample sig2 #############

res=0
for(i in 1:n)
res=res+(Y[i]-X[i,]%*%mu[,H[i]])^2;

ap=n/2+r1;
be=res/2+r2
sig2=rinvgamma(1,ap,be);


########## sample z and mu, w and tau_p2 #############
#sample z and mu
for (k in 1:K){
idk=id[H==k]

for (j in 1:p){

if (length(idk)==0) {dis_mm<-rep(0,(p))} # for safety to keep MCMC chain
if (length(idk)==1){ dis_mm<-sqrt((X1[idk,j]-X1[idk,])^2)}
if (length(idk)>1) {dis_mm <- colSums(sqrt((X1[idk,j]-X1[idk,])^2))} #Euclidean distance

thq<-quantile(dis_mm,cutoff) 

setid<-which(dis_mm<thq) ## members of neighbors
set <- z[setid,k] #a set of selected co-occuring words
Zk_1 <- sum(set==1) #how many of selected neighbor words

if(sum(setid)==0) {setidS[j,,k]<-0} else { 
setidS[j,(1:length(setid)),k]<-setid} #save set id

	# sample Z
	eps = Y[idk]-X[idk,-j]%*%mu[-j,k];
	tmpmean = sum(eps*X[idk,j])/sig2;
	tmpvar = V[j,k]/sig2+1/tau2[j]; 
	logr= (-J*Zk_1) + log(V[j,k]*tau2[j]/sig2+1)/2 - tmpmean^2/tmpvar/2
	if (logr>100) logr=100
	z[j,k]=ifelse(runif(1)< 1/(1+exp(logr)),1,0);

	# sample mu
	if (z[j,k]==0) mu[j,k]=0 else {
		bjmu = tmpmean/tmpvar;
		mu[j,k]=rnorm(1,bjmu,1/sqrt(tmpvar))
	}
}#for j
}#for k

#aw=sum(z); bw=p*K-aw;
#w=rbeta(1,aw+a, bw+b);

##taup2
at=rep(0,p)
bt=rep(0,p)

for (j in 1:p){
aw1=sum(z[j,])
bw1=(sum(mu[j,]^2))

at[j]=aw1/2+sp1
bt[j]=bw1*sum(z[j,])/2+sp2
tau2[j]=rinvgamma(1,at[j],bt[j]);
}


########## sample H and d ##################
d=as.vector(rdirichlet(1, nk+theta));

wp=matrix(0,K,n);
for(i in 1:n)
for(k in 1:K)
wp[k,i]=exp(-(Y[i]-X[i,]%*%mu[,k])^2/(2*sig2)) 

for (k in 1:K)
wp[k,]=wp[k,]*d[k]

for (i in 1:n){
H[i]=sample(1:K,1,replace=TRUE,wp[,i])
}


########## reordering ##################

newp=reorder(mu,H,z,d);
mu=newp$mu;
H=newp$H;
z=newp$z;
d=newp$d;


########## save posterior samples ########

if(iter>T0){
tmpT=iter-T0;
postz[,,tmpT]=z;
posttau2[tmpT,]=tau2
postmu[,,tmpT]=mu;
postw=c(postw,w);
postsig2=c(postsig2,sig2)
postd[tmpT,]=d
postH[tmpT,]=H;
postnk[tmpT,]=nk;

setidT[,,,tmpT]<-setidS ## selected neighbors per each variable across all MCMC runs

}


} # End of MCMC


## Posterior mean of beta ##

ss=matrix(0,p,K) 
for (i in 1:p)
for (j in 1:K)
{ 
ss[i,j]=mean(postmu[i,j,])
} 



## Posterior mean of Z ##

tt=matrix(0,p,K)
for (i in 1:p)
for (j in 1:K)
{ 
tt[i,j]=mean(postz[i,j,])
}

round(ss,1)
round(mu_t,1)

#########################
## computing min MAE ####
#########################

set_f<-permutations(K, K)

trial<-dim(set_f)[1]

ss0<-array(0, c(p,K,trial))

## build all possible sets of ss

for (f in 1:trial){

ll<-set_f[f,]

for (k in 1:K){

ss0[,k,f]<-ss[,ll[k]]

}# for k
}# for trial

temp_MAE<-rep(0,trial)
temp_RMSE<-rep(0,trial)

for (f in 1:trial){

temp_MAE[f] <- mean(abs(ss0[,,f]-mu_t))
temp_RMSE[f] <- sqrt(mean((ss0[,,f]-mu_t)^2))

}#f



## membership calucation ##

memb=rep(0,n)
for (i in 1:n)
memb[i]<-as.numeric(names(table(postH[,i]))[which.max(table(postH[,i]))]) 
table(memb)


########################


## finding neighbor structure

dim(setidT)


## finding dimensions -- post-hoc searching ##


joint_D <- array(0,c(p,p,K)) 

for (k in 1:K){
for (j in 1:p){
for (l in 1:p){
joint_D [j,l,k] <- sum(setidT[j,,k,]==l)
}
}
}

for (k in 1:K)
diag(joint_D[,,k])<-T ## segment-level neighbors

## Heuristic Search ## 
cut=0.95
P_dim=array(0,c(p,p,K))
S_sel=array(0,c(p,p,K))

## find segmentment-level neighborsets!


for (k in 1:K){
for(j in 1:p){
pdim = which(joint_D[j,,k] > (cut*T)) # probabilistic segment-level neighbors 
sel_t <-which(tt[,k]>0.95)
pdim0<-intersect(pdim,sel_t) # selected neighbors
ssel<-setdiff(sel_t, pdim0)
if(sum(pdim0)>0){
P_dim[j,1:length(pdim0),k]<-pdim0} #Co-occuring selected variables; as cooccuring variables are active...
if(sum(ssel)>0){
S_sel[j,1:length(ssel),k]<-ssel
} 
}
}

#selected neighbors per each j word


# DV: % of cooccuring variables are successfully recovered.



#### for simulation data ####

dist_R=rep(0,K)

for (k in 1:K){

symm_M<-matrix(0,p,p)

for (j in 1:p){

tmp_i<- P_dim[j,,k]
symm_M[j,tmp_i]=1

}

colnames(symm_M)<-as.character(1:p)
rownames(symm_M)<-as.character(1:p)


sel_t <-which(tt[,k]>0.95)

symm_M0<-symm_M[sel_t,sel_t] #### a matrix of the neighbor structure of selected variables

## each row includes its selected neighbors in columns

group.dist=rep(0,K)

for (l in 1:K){

dm0<-dm[[l]]

seg.dist1<-as.matrix(dist(symm_M0)) 


set0<-combinations(p1,2)
dim(set0)[1]
colnames(seg.dist1)
rownames(seg.dist1)

if( length(intersect (as.character(dm0),  colnames(seg.dist1)))< p1  ) {group.dist[l]=1000}else{


distset<-rep(0,(dim(set0)[1]))

for (i in 1:(dim(set0)[1])){

coln<-which(as.character(dm0[set0[i,]][1]) == colnames(seg.dist1))
rown<-which(as.character(dm0[set0[i,]][2]) == rownames(seg.dist1))
distset[i]<-seg.dist1[rown,coln]

}#for i


group.dist[l]=mean(distset)

}#else


totaln<-(dim(seg.dist1)[1]*dim(seg.dist1)[2]-dim(seg.dist1)[1])/2

sum( seg.dist1)/totaln

min(group.dist)/(sum( seg.dist1)/totaln)

dist_R[k]<-min(group.dist)/(sum( seg.dist1)/totaln)

} # for l

} #for k






# mean(dist_R, na.rm=TRUE)

### } #### for mt





set_f<-permutations(K, K)


array_over=array(100,c(p1,K,dim(set_f)[1]))

abs_value<-rep(100,dim(set_f)[1])

for (f in 1:trial){

ll<-set_f[f,]

over_select=matrix(100,p1,K)

for (k in 1:K){

symm_M<-matrix(0,p,p)

for (j in 1:p){

tmp_i<- P_dim[j,,k]
symm_M[j,tmp_i]=1

}

colnames(symm_M)<-as.character(1:p)
rownames(symm_M)<-as.character(1:p)


sel_t <-which(tt[,k]>0.95)

symm_M0<-symm_M[sel_t,sel_t] 



for (i in 1:p1){

j0<-which(dm[[ll[k]]][i] == as.numeric(rownames(symm_M0)))

j1<-which(symm_M0[j0,]==1)

over_select[i,k] = length(intersect(as.numeric(colnames(symm_M0)),as.numeric(names(j1))))-p1

}#for i

}#for k

array_over[,,f]=over_select

abs_value[f]=sum(abs(array_over[,,f]))

}#f


tem_M<-array_over[,,which.min(abs_value)]

#sum(abs(array_over[,,which.min(abs_value)]))/(p1*K)

MAE[mt]<-min(temp_MAE)


OVER[mt]<-sum(tem_M[which(tem_M>0)])/(p1)/(length(which(tt>0.95))-(p1*K))


UNDER[mt]<-sum(tem_M[which(tem_M<0)])/(p1*K*p1) #percentage

}

MAE
OVER
UNDER

